{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.webhook = exports.validateExpressRequest = exports.validateIncomingRequest = exports.validateRequestWithBody = exports.validateBody = exports.validateRequest = exports.getExpectedBodyHash = exports.getExpectedTwilioSignature = void 0;\nconst scmp = require(\"scmp\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst querystring_1 = require(\"querystring\");\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param parsedUrl - The parsed url object that Twilio requested on your server\n * @returns URL with standard port number included\n */\nfunction buildUrlWithStandardPort(parsedUrl) {\n  let url = \"\";\n  const port = parsedUrl.protocol === \"https:\" ? \":443\" : \":80\";\n  url += parsedUrl.protocol ? parsedUrl.protocol + \"//\" : \"\";\n  url += parsedUrl.username;\n  url += parsedUrl.password ? \":\" + parsedUrl.password : \"\";\n  url += parsedUrl.username || parsedUrl.password ? \"@\" : \"\";\n  url += parsedUrl.host ? parsedUrl.host + port : \"\";\n  url += parsedUrl.pathname + parsedUrl.search + parsedUrl.hash;\n  return url;\n}\n/**\n Utility function to add a port number to a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL with port\n */\nfunction addPort(parsedUrl) {\n  if (!parsedUrl.port) {\n    return buildUrlWithStandardPort(parsedUrl);\n  }\n  return parsedUrl.toString();\n}\n/**\n Utility function to remove a port number from a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL without port\n */\nfunction removePort(parsedUrl) {\n  parsedUrl = new URL(parsedUrl); // prevent mutation of original URL object\n  parsedUrl.port = \"\";\n  return parsedUrl.toString();\n}\nfunction withLegacyQuerystring(url) {\n  const parsedUrl = new URL(url);\n  if (parsedUrl.search) {\n    const qs = (0, querystring_1.parse)(parsedUrl.search.slice(1));\n    parsedUrl.search = \"\";\n    return parsedUrl.toString() + \"?\" + (0, querystring_1.stringify)(qs);\n  }\n  return url;\n}\n/**\n Utility function to convert request parameter to a string format\n\n @param paramName - The request parameter name\n @param paramValue - The request parameter value\n @returns Formatted parameter string\n */\nfunction toFormUrlEncodedParam(paramName, paramValue) {\n  if (paramValue instanceof Array) {\n    return Array.from(new Set(paramValue)).sort().map(val => toFormUrlEncodedParam(paramName, val)).reduce((acc, val) => acc + val, \"\");\n  }\n  return paramName + paramValue;\n}\n/**\n Utility function to get the expected signature for a given request\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param url - The full URL (with query string) you configured to handle\n this request\n @param params - the parameters sent with this request\n @returns signature\n */\nfunction getExpectedTwilioSignature(authToken, url, params) {\n  if (url.indexOf(\"bodySHA256\") !== -1 && params === null) {\n    params = {};\n  }\n  var data = Object.keys(params).sort().reduce((acc, key) => acc + toFormUrlEncodedParam(key, params[key]), url);\n  return crypto_1.default.createHmac(\"sha1\", authToken).update(Buffer.from(data, \"utf-8\")).digest(\"base64\");\n}\nexports.getExpectedTwilioSignature = getExpectedTwilioSignature;\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param body - The plain-text body of the request\n */\nfunction getExpectedBodyHash(body) {\n  return crypto_1.default.createHash(\"sha256\").update(Buffer.from(body, \"utf-8\")).digest(\"hex\");\n}\nexports.getExpectedBodyHash = getExpectedBodyHash;\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param params - the parameters sent with this request\n @returns valid\n */\nfunction validateRequest(authToken, twilioHeader, url, params) {\n  twilioHeader = twilioHeader || \"\";\n  const urlObject = new URL(url);\n  /*\n   *  Check signature of the url with and without the port number\n   *  and with and without the legacy querystring (special chars are encoded when using `new URL()`)\n   *  since signature generation on the back end is inconsistent\n   */\n  const isValidSignatureWithoutPort = validateSignatureWithUrl(authToken, twilioHeader, removePort(urlObject), params);\n  if (isValidSignatureWithoutPort) {\n    return true;\n  }\n  const isValidSignatureWithPort = validateSignatureWithUrl(authToken, twilioHeader, addPort(urlObject), params);\n  if (isValidSignatureWithPort) {\n    return true;\n  }\n  const isValidSignatureWithLegacyQuerystringWithoutPort = validateSignatureWithUrl(authToken, twilioHeader, withLegacyQuerystring(removePort(urlObject)), params);\n  if (isValidSignatureWithLegacyQuerystringWithoutPort) {\n    return true;\n  }\n  const isValidSignatureWithLegacyQuerystringWithPort = validateSignatureWithUrl(authToken, twilioHeader, withLegacyQuerystring(addPort(urlObject)), params);\n  return isValidSignatureWithLegacyQuerystringWithPort;\n}\nexports.validateRequest = validateRequest;\nfunction validateSignatureWithUrl(authToken, twilioHeader, url, params) {\n  const signatureWithoutPort = getExpectedTwilioSignature(authToken, url, params);\n  return scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n}\nfunction validateBody(body, bodyHash) {\n  var expectedHash = getExpectedBodyHash(body);\n  return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\nexports.validateBody = validateBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param body - The body of the request\n @returns valid\n */\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n  const urlObject = new URL(url);\n  return validateRequest(authToken, twilioHeader, url, {}) && validateBody(body, urlObject.searchParams.get(\"bodySHA256\") || \"\");\n}\nexports.validateRequestWithBody = validateRequestWithBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio.\n adapted from https://github.com/crabasa/twiliosig\n\n @param request - A request object (based on Express implementation http://expressjs.com/api.html#req.params)\n @param authToken - The auth token, as seen in the Twilio portal\n @param opts - options for request validation:\n    -> url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    -> host: manually specify the host name used by Twilio in a number's webhook config\n    -> protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\nfunction validateIncomingRequest(request, authToken, opts) {\n  var options = opts || {};\n  var webhookUrl;\n  if (options.url) {\n    // Let the user specify the full URL\n    webhookUrl = options.url;\n  } else {\n    // Use configured host/protocol, or infer based on request\n    var protocol = options.protocol || request.protocol;\n    var host = options.host || request.headers.host;\n    webhookUrl = url_1.default.format({\n      protocol: protocol,\n      host: host,\n      pathname: request.originalUrl\n    });\n    if (request.originalUrl.search(/\\?/) >= 0) {\n      webhookUrl = webhookUrl.replace(/%3F/g, \"?\");\n    }\n  }\n  if (webhookUrl.indexOf(\"bodySHA256\") > 0) {\n    return validateRequestWithBody(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.rawBody || \"{}\");\n  } else {\n    return validateRequest(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.body || {});\n  }\n}\nexports.validateIncomingRequest = validateIncomingRequest;\nfunction validateExpressRequest(request, authToken, opts) {\n  return validateIncomingRequest(request, authToken, opts);\n}\nexports.validateExpressRequest = validateExpressRequest;\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\nfunction webhook(opts, authToken) {\n  let token;\n  let options = undefined;\n  // Narrowing the args\n  if (opts) {\n    if (typeof opts === \"string\") {\n      token = opts;\n    }\n    if (typeof opts === \"object\") {\n      options = opts;\n    }\n  }\n  if (authToken) {\n    if (typeof authToken === \"string\") {\n      token = authToken;\n    }\n    if (typeof authToken === \"object\") {\n      options = authToken;\n    }\n  }\n  if (!options) options = {};\n  if (options.validate == undefined) options.validate = true;\n  // Process arguments\n  var tokenString;\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n    if (typeof arg === \"string\") {\n      tokenString = arg;\n    } else {\n      options = Object.assign(options || {}, arg);\n    }\n  }\n  // set auth token from input or environment variable\n  if (options) {\n    options.authToken = tokenString ? tokenString : process.env.TWILIO_AUTH_TOKEN;\n  }\n  // Create middleware function\n  return function hook(request, response, next) {\n    // Do validation if requested\n    if (options?.validate) {\n      // Check if the 'X-Twilio-Signature' header exists or not\n      if (!request.header(\"X-Twilio-Signature\")) {\n        return response.type(\"text/plain\").status(400).send(\"No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.\");\n      }\n      // Check for a valid auth token\n      if (!options?.authToken) {\n        console.error(\"[Twilio]: Error - Twilio auth token is required for webhook request validation.\");\n        response.type(\"text/plain\").status(500).send(\"Webhook Error - we attempted to validate this request without first configuring our auth token.\");\n      } else {\n        // Check that the request originated from Twilio\n        var valid = validateExpressRequest(request, options?.authToken, {\n          url: options?.url,\n          host: options?.host,\n          protocol: options?.protocol\n        });\n        if (valid) {\n          next();\n        } else {\n          return response.type(\"text/plain\").status(403).send(\"Twilio Request Validation Failed.\");\n        }\n      }\n    } else {\n      next();\n    }\n  };\n}\nexports.webhook = webhook;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","webhook","validateExpressRequest","validateIncomingRequest","validateRequestWithBody","validateBody","validateRequest","getExpectedBodyHash","getExpectedTwilioSignature","scmp","require","crypto_1","url_1","querystring_1","buildUrlWithStandardPort","parsedUrl","url","port","protocol","username","password","host","pathname","search","hash","addPort","toString","removePort","URL","withLegacyQuerystring","qs","parse","slice","stringify","toFormUrlEncodedParam","paramName","paramValue","Array","from","Set","sort","map","val","reduce","acc","authToken","params","indexOf","data","keys","key","default","createHmac","update","Buffer","digest","body","createHash","twilioHeader","urlObject","isValidSignatureWithoutPort","validateSignatureWithUrl","isValidSignatureWithPort","isValidSignatureWithLegacyQuerystringWithoutPort","isValidSignatureWithLegacyQuerystringWithPort","signatureWithoutPort","bodyHash","expectedHash","searchParams","get","request","opts","options","webhookUrl","headers","format","originalUrl","replace","header","rawBody","token","undefined","validate","tokenString","i","l","arguments","length","arg","assign","process","env","TWILIO_AUTH_TOKEN","hook","response","next","type","status","send","console","error","valid"],"sources":["D:/agri-community/client/node_modules/twilio/lib/webhooks/webhooks.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webhook = exports.validateExpressRequest = exports.validateIncomingRequest = exports.validateRequestWithBody = exports.validateBody = exports.validateRequest = exports.getExpectedBodyHash = exports.getExpectedTwilioSignature = void 0;\nconst scmp = require(\"scmp\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst querystring_1 = require(\"querystring\");\n/**\n * Utility function to construct the URL string, since Node.js url library won't include standard port numbers\n *\n * @param parsedUrl - The parsed url object that Twilio requested on your server\n * @returns URL with standard port number included\n */\nfunction buildUrlWithStandardPort(parsedUrl) {\n    let url = \"\";\n    const port = parsedUrl.protocol === \"https:\" ? \":443\" : \":80\";\n    url += parsedUrl.protocol ? parsedUrl.protocol + \"//\" : \"\";\n    url += parsedUrl.username;\n    url += parsedUrl.password ? \":\" + parsedUrl.password : \"\";\n    url += parsedUrl.username || parsedUrl.password ? \"@\" : \"\";\n    url += parsedUrl.host ? parsedUrl.host + port : \"\";\n    url += parsedUrl.pathname + parsedUrl.search + parsedUrl.hash;\n    return url;\n}\n/**\n Utility function to add a port number to a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL with port\n */\nfunction addPort(parsedUrl) {\n    if (!parsedUrl.port) {\n        return buildUrlWithStandardPort(parsedUrl);\n    }\n    return parsedUrl.toString();\n}\n/**\n Utility function to remove a port number from a URL\n\n @param parsedUrl - The parsed url object that Twilio requested on your server\n @returns URL without port\n */\nfunction removePort(parsedUrl) {\n    parsedUrl = new URL(parsedUrl); // prevent mutation of original URL object\n    parsedUrl.port = \"\";\n    return parsedUrl.toString();\n}\nfunction withLegacyQuerystring(url) {\n    const parsedUrl = new URL(url);\n    if (parsedUrl.search) {\n        const qs = (0, querystring_1.parse)(parsedUrl.search.slice(1));\n        parsedUrl.search = \"\";\n        return parsedUrl.toString() + \"?\" + (0, querystring_1.stringify)(qs);\n    }\n    return url;\n}\n/**\n Utility function to convert request parameter to a string format\n\n @param paramName - The request parameter name\n @param paramValue - The request parameter value\n @returns Formatted parameter string\n */\nfunction toFormUrlEncodedParam(paramName, paramValue) {\n    if (paramValue instanceof Array) {\n        return Array.from(new Set(paramValue))\n            .sort()\n            .map((val) => toFormUrlEncodedParam(paramName, val))\n            .reduce((acc, val) => acc + val, \"\");\n    }\n    return paramName + paramValue;\n}\n/**\n Utility function to get the expected signature for a given request\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param url - The full URL (with query string) you configured to handle\n this request\n @param params - the parameters sent with this request\n @returns signature\n */\nfunction getExpectedTwilioSignature(authToken, url, params) {\n    if (url.indexOf(\"bodySHA256\") !== -1 && params === null) {\n        params = {};\n    }\n    var data = Object.keys(params)\n        .sort()\n        .reduce((acc, key) => acc + toFormUrlEncodedParam(key, params[key]), url);\n    return crypto_1.default\n        .createHmac(\"sha1\", authToken)\n        .update(Buffer.from(data, \"utf-8\"))\n        .digest(\"base64\");\n}\nexports.getExpectedTwilioSignature = getExpectedTwilioSignature;\n/**\n Utility function to get the expected body hash for a given request's body\n\n @param body - The plain-text body of the request\n */\nfunction getExpectedBodyHash(body) {\n    return crypto_1.default\n        .createHash(\"sha256\")\n        .update(Buffer.from(body, \"utf-8\"))\n        .digest(\"hex\");\n}\nexports.getExpectedBodyHash = getExpectedBodyHash;\n/**\n Utility function to validate an incoming request is indeed from Twilio\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param params - the parameters sent with this request\n @returns valid\n */\nfunction validateRequest(authToken, twilioHeader, url, params) {\n    twilioHeader = twilioHeader || \"\";\n    const urlObject = new URL(url);\n    /*\n     *  Check signature of the url with and without the port number\n     *  and with and without the legacy querystring (special chars are encoded when using `new URL()`)\n     *  since signature generation on the back end is inconsistent\n     */\n    const isValidSignatureWithoutPort = validateSignatureWithUrl(authToken, twilioHeader, removePort(urlObject), params);\n    if (isValidSignatureWithoutPort) {\n        return true;\n    }\n    const isValidSignatureWithPort = validateSignatureWithUrl(authToken, twilioHeader, addPort(urlObject), params);\n    if (isValidSignatureWithPort) {\n        return true;\n    }\n    const isValidSignatureWithLegacyQuerystringWithoutPort = validateSignatureWithUrl(authToken, twilioHeader, withLegacyQuerystring(removePort(urlObject)), params);\n    if (isValidSignatureWithLegacyQuerystringWithoutPort) {\n        return true;\n    }\n    const isValidSignatureWithLegacyQuerystringWithPort = validateSignatureWithUrl(authToken, twilioHeader, withLegacyQuerystring(addPort(urlObject)), params);\n    return isValidSignatureWithLegacyQuerystringWithPort;\n}\nexports.validateRequest = validateRequest;\nfunction validateSignatureWithUrl(authToken, twilioHeader, url, params) {\n    const signatureWithoutPort = getExpectedTwilioSignature(authToken, url, params);\n    return scmp(Buffer.from(twilioHeader), Buffer.from(signatureWithoutPort));\n}\nfunction validateBody(body, bodyHash) {\n    var expectedHash = getExpectedBodyHash(body);\n    return scmp(Buffer.from(bodyHash), Buffer.from(expectedHash));\n}\nexports.validateBody = validateBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio. This also validates\n the request body against the bodySHA256 post parameter.\n\n @param authToken - The auth token, as seen in the Twilio portal\n @param twilioHeader - The value of the X-Twilio-Signature header from the request\n @param url - The full URL (with query string) you configured to handle this request\n @param body - The body of the request\n @returns valid\n */\nfunction validateRequestWithBody(authToken, twilioHeader, url, body) {\n    const urlObject = new URL(url);\n    return (validateRequest(authToken, twilioHeader, url, {}) &&\n        validateBody(body, urlObject.searchParams.get(\"bodySHA256\") || \"\"));\n}\nexports.validateRequestWithBody = validateRequestWithBody;\n/**\n Utility function to validate an incoming request is indeed from Twilio.\n adapted from https://github.com/crabasa/twiliosig\n\n @param request - A request object (based on Express implementation http://expressjs.com/api.html#req.params)\n @param authToken - The auth token, as seen in the Twilio portal\n @param opts - options for request validation:\n    -> url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n    -> host: manually specify the host name used by Twilio in a number's webhook config\n    -> protocol: manually specify the protocol used by Twilio in a number's webhook config\n */\nfunction validateIncomingRequest(request, authToken, opts) {\n    var options = opts || {};\n    var webhookUrl;\n    if (options.url) {\n        // Let the user specify the full URL\n        webhookUrl = options.url;\n    }\n    else {\n        // Use configured host/protocol, or infer based on request\n        var protocol = options.protocol || request.protocol;\n        var host = options.host || request.headers.host;\n        webhookUrl = url_1.default.format({\n            protocol: protocol,\n            host: host,\n            pathname: request.originalUrl,\n        });\n        if (request.originalUrl.search(/\\?/) >= 0) {\n            webhookUrl = webhookUrl.replace(/%3F/g, \"?\");\n        }\n    }\n    if (webhookUrl.indexOf(\"bodySHA256\") > 0) {\n        return validateRequestWithBody(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.rawBody || \"{}\");\n    }\n    else {\n        return validateRequest(authToken, request.header(\"X-Twilio-Signature\") || \"\", webhookUrl, request.body || {});\n    }\n}\nexports.validateIncomingRequest = validateIncomingRequest;\nfunction validateExpressRequest(request, authToken, opts) {\n    return validateIncomingRequest(request, authToken, opts);\n}\nexports.validateExpressRequest = validateExpressRequest;\n/**\nExpress middleware to accompany a Twilio webhook. Provides Twilio\nrequest validation, and makes the response a little more friendly for our\nTwiML generator.  Request validation requires the express.urlencoded middleware\nto have been applied (e.g. app.use(express.urlencoded()); in your app config).\n\nOptions:\n- validate: {Boolean} whether or not the middleware should validate the request\n    came from Twilio.  Default true. If the request does not originate from\n    Twilio, we will return a text body and a 403.  If there is no configured\n    auth token and validate=true, this is an error condition, so we will return\n    a 500.\n- host: manually specify the host name used by Twilio in a number's webhook config\n- protocol: manually specify the protocol used by Twilio in a number's webhook config\n- url: The full URL (with query string) you used to configure the webhook with Twilio - overrides host/protocol options\n\nReturns a middleware function.\n\nExamples:\nvar webhookMiddleware = twilio.webhook();\nvar webhookMiddleware = twilio.webhook('asdha9dhjasd'); //init with auth token\nvar webhookMiddleware = twilio.webhook({\n    validate:false // don't attempt request validation\n});\nvar webhookMiddleware = twilio.webhook({\n    host: 'hook.twilio.com',\n    protocol: 'https'\n});\n */\nfunction webhook(opts, authToken) {\n    let token;\n    let options = undefined;\n    // Narrowing the args\n    if (opts) {\n        if (typeof opts === \"string\") {\n            token = opts;\n        }\n        if (typeof opts === \"object\") {\n            options = opts;\n        }\n    }\n    if (authToken) {\n        if (typeof authToken === \"string\") {\n            token = authToken;\n        }\n        if (typeof authToken === \"object\") {\n            options = authToken;\n        }\n    }\n    if (!options)\n        options = {};\n    if (options.validate == undefined)\n        options.validate = true;\n    // Process arguments\n    var tokenString;\n    for (var i = 0, l = arguments.length; i < l; i++) {\n        var arg = arguments[i];\n        if (typeof arg === \"string\") {\n            tokenString = arg;\n        }\n        else {\n            options = Object.assign(options || {}, arg);\n        }\n    }\n    // set auth token from input or environment variable\n    if (options) {\n        options.authToken = tokenString\n            ? tokenString\n            : process.env.TWILIO_AUTH_TOKEN;\n    }\n    // Create middleware function\n    return function hook(request, response, next) {\n        // Do validation if requested\n        if (options?.validate) {\n            // Check if the 'X-Twilio-Signature' header exists or not\n            if (!request.header(\"X-Twilio-Signature\")) {\n                return response\n                    .type(\"text/plain\")\n                    .status(400)\n                    .send(\"No signature header error - X-Twilio-Signature header does not exist, maybe this request is not coming from Twilio.\");\n            }\n            // Check for a valid auth token\n            if (!options?.authToken) {\n                console.error(\"[Twilio]: Error - Twilio auth token is required for webhook request validation.\");\n                response\n                    .type(\"text/plain\")\n                    .status(500)\n                    .send(\"Webhook Error - we attempted to validate this request without first configuring our auth token.\");\n            }\n            else {\n                // Check that the request originated from Twilio\n                var valid = validateExpressRequest(request, options?.authToken, {\n                    url: options?.url,\n                    host: options?.host,\n                    protocol: options?.protocol,\n                });\n                if (valid) {\n                    next();\n                }\n                else {\n                    return response\n                        .type(\"text/plain\")\n                        .status(403)\n                        .send(\"Twilio Request Validation Failed.\");\n                }\n            }\n        }\n        else {\n            next();\n        }\n    };\n}\nexports.webhook = webhook;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAGF,OAAO,CAACG,sBAAsB,GAAGH,OAAO,CAACI,uBAAuB,GAAGJ,OAAO,CAACK,uBAAuB,GAAGL,OAAO,CAACM,YAAY,GAAGN,OAAO,CAACO,eAAe,GAAGP,OAAO,CAACQ,mBAAmB,GAAGR,OAAO,CAACS,0BAA0B,GAAG,KAAK,CAAC;AACjP,MAAMC,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,QAAQ,GAAGjB,eAAe,CAACgB,OAAO,CAAC,QAAQ,CAAC,CAAC;AACnD,MAAME,KAAK,GAAGlB,eAAe,CAACgB,OAAO,CAAC,KAAK,CAAC,CAAC;AAC7C,MAAMG,aAAa,GAAGH,OAAO,CAAC,aAAa,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,wBAAwBA,CAACC,SAAS,EAAE;EACzC,IAAIC,GAAG,GAAG,EAAE;EACZ,MAAMC,IAAI,GAAGF,SAAS,CAACG,QAAQ,KAAK,QAAQ,GAAG,MAAM,GAAG,KAAK;EAC7DF,GAAG,IAAID,SAAS,CAACG,QAAQ,GAAGH,SAAS,CAACG,QAAQ,GAAG,IAAI,GAAG,EAAE;EAC1DF,GAAG,IAAID,SAAS,CAACI,QAAQ;EACzBH,GAAG,IAAID,SAAS,CAACK,QAAQ,GAAG,GAAG,GAAGL,SAAS,CAACK,QAAQ,GAAG,EAAE;EACzDJ,GAAG,IAAID,SAAS,CAACI,QAAQ,IAAIJ,SAAS,CAACK,QAAQ,GAAG,GAAG,GAAG,EAAE;EAC1DJ,GAAG,IAAID,SAAS,CAACM,IAAI,GAAGN,SAAS,CAACM,IAAI,GAAGJ,IAAI,GAAG,EAAE;EAClDD,GAAG,IAAID,SAAS,CAACO,QAAQ,GAAGP,SAAS,CAACQ,MAAM,GAAGR,SAAS,CAACS,IAAI;EAC7D,OAAOR,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,OAAOA,CAACV,SAAS,EAAE;EACxB,IAAI,CAACA,SAAS,CAACE,IAAI,EAAE;IACjB,OAAOH,wBAAwB,CAACC,SAAS,CAAC;EAC9C;EACA,OAAOA,SAAS,CAACW,QAAQ,CAAC,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACZ,SAAS,EAAE;EAC3BA,SAAS,GAAG,IAAIa,GAAG,CAACb,SAAS,CAAC,CAAC,CAAC;EAChCA,SAAS,CAACE,IAAI,GAAG,EAAE;EACnB,OAAOF,SAAS,CAACW,QAAQ,CAAC,CAAC;AAC/B;AACA,SAASG,qBAAqBA,CAACb,GAAG,EAAE;EAChC,MAAMD,SAAS,GAAG,IAAIa,GAAG,CAACZ,GAAG,CAAC;EAC9B,IAAID,SAAS,CAACQ,MAAM,EAAE;IAClB,MAAMO,EAAE,GAAG,CAAC,CAAC,EAAEjB,aAAa,CAACkB,KAAK,EAAEhB,SAAS,CAACQ,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9DjB,SAAS,CAACQ,MAAM,GAAG,EAAE;IACrB,OAAOR,SAAS,CAACW,QAAQ,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,EAAEb,aAAa,CAACoB,SAAS,EAAEH,EAAE,CAAC;EACxE;EACA,OAAOd,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,qBAAqBA,CAACC,SAAS,EAAEC,UAAU,EAAE;EAClD,IAAIA,UAAU,YAAYC,KAAK,EAAE;IAC7B,OAAOA,KAAK,CAACC,IAAI,CAAC,IAAIC,GAAG,CAACH,UAAU,CAAC,CAAC,CACjCI,IAAI,CAAC,CAAC,CACNC,GAAG,CAAEC,GAAG,IAAKR,qBAAqB,CAACC,SAAS,EAAEO,GAAG,CAAC,CAAC,CACnDC,MAAM,CAAC,CAACC,GAAG,EAAEF,GAAG,KAAKE,GAAG,GAAGF,GAAG,EAAE,EAAE,CAAC;EAC5C;EACA,OAAOP,SAAS,GAAGC,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS5B,0BAA0BA,CAACqC,SAAS,EAAE7B,GAAG,EAAE8B,MAAM,EAAE;EACxD,IAAI9B,GAAG,CAAC+B,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,IAAID,MAAM,KAAK,IAAI,EAAE;IACrDA,MAAM,GAAG,CAAC,CAAC;EACf;EACA,IAAIE,IAAI,GAAGnD,MAAM,CAACoD,IAAI,CAACH,MAAM,CAAC,CACzBN,IAAI,CAAC,CAAC,CACNG,MAAM,CAAC,CAACC,GAAG,EAAEM,GAAG,KAAKN,GAAG,GAAGV,qBAAqB,CAACgB,GAAG,EAAEJ,MAAM,CAACI,GAAG,CAAC,CAAC,EAAElC,GAAG,CAAC;EAC7E,OAAOL,QAAQ,CAACwC,OAAO,CAClBC,UAAU,CAAC,MAAM,EAAEP,SAAS,CAAC,CAC7BQ,MAAM,CAACC,MAAM,CAAChB,IAAI,CAACU,IAAI,EAAE,OAAO,CAAC,CAAC,CAClCO,MAAM,CAAC,QAAQ,CAAC;AACzB;AACAxD,OAAO,CAACS,0BAA0B,GAAGA,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA,SAASD,mBAAmBA,CAACiD,IAAI,EAAE;EAC/B,OAAO7C,QAAQ,CAACwC,OAAO,CAClBM,UAAU,CAAC,QAAQ,CAAC,CACpBJ,MAAM,CAACC,MAAM,CAAChB,IAAI,CAACkB,IAAI,EAAE,OAAO,CAAC,CAAC,CAClCD,MAAM,CAAC,KAAK,CAAC;AACtB;AACAxD,OAAO,CAACQ,mBAAmB,GAAGA,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,eAAeA,CAACuC,SAAS,EAAEa,YAAY,EAAE1C,GAAG,EAAE8B,MAAM,EAAE;EAC3DY,YAAY,GAAGA,YAAY,IAAI,EAAE;EACjC,MAAMC,SAAS,GAAG,IAAI/B,GAAG,CAACZ,GAAG,CAAC;EAC9B;AACJ;AACA;AACA;AACA;EACI,MAAM4C,2BAA2B,GAAGC,wBAAwB,CAAChB,SAAS,EAAEa,YAAY,EAAE/B,UAAU,CAACgC,SAAS,CAAC,EAAEb,MAAM,CAAC;EACpH,IAAIc,2BAA2B,EAAE;IAC7B,OAAO,IAAI;EACf;EACA,MAAME,wBAAwB,GAAGD,wBAAwB,CAAChB,SAAS,EAAEa,YAAY,EAAEjC,OAAO,CAACkC,SAAS,CAAC,EAAEb,MAAM,CAAC;EAC9G,IAAIgB,wBAAwB,EAAE;IAC1B,OAAO,IAAI;EACf;EACA,MAAMC,gDAAgD,GAAGF,wBAAwB,CAAChB,SAAS,EAAEa,YAAY,EAAE7B,qBAAqB,CAACF,UAAU,CAACgC,SAAS,CAAC,CAAC,EAAEb,MAAM,CAAC;EAChK,IAAIiB,gDAAgD,EAAE;IAClD,OAAO,IAAI;EACf;EACA,MAAMC,6CAA6C,GAAGH,wBAAwB,CAAChB,SAAS,EAAEa,YAAY,EAAE7B,qBAAqB,CAACJ,OAAO,CAACkC,SAAS,CAAC,CAAC,EAAEb,MAAM,CAAC;EAC1J,OAAOkB,6CAA6C;AACxD;AACAjE,OAAO,CAACO,eAAe,GAAGA,eAAe;AACzC,SAASuD,wBAAwBA,CAAChB,SAAS,EAAEa,YAAY,EAAE1C,GAAG,EAAE8B,MAAM,EAAE;EACpE,MAAMmB,oBAAoB,GAAGzD,0BAA0B,CAACqC,SAAS,EAAE7B,GAAG,EAAE8B,MAAM,CAAC;EAC/E,OAAOrC,IAAI,CAAC6C,MAAM,CAAChB,IAAI,CAACoB,YAAY,CAAC,EAAEJ,MAAM,CAAChB,IAAI,CAAC2B,oBAAoB,CAAC,CAAC;AAC7E;AACA,SAAS5D,YAAYA,CAACmD,IAAI,EAAEU,QAAQ,EAAE;EAClC,IAAIC,YAAY,GAAG5D,mBAAmB,CAACiD,IAAI,CAAC;EAC5C,OAAO/C,IAAI,CAAC6C,MAAM,CAAChB,IAAI,CAAC4B,QAAQ,CAAC,EAAEZ,MAAM,CAAChB,IAAI,CAAC6B,YAAY,CAAC,CAAC;AACjE;AACApE,OAAO,CAACM,YAAY,GAAGA,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,uBAAuBA,CAACyC,SAAS,EAAEa,YAAY,EAAE1C,GAAG,EAAEwC,IAAI,EAAE;EACjE,MAAMG,SAAS,GAAG,IAAI/B,GAAG,CAACZ,GAAG,CAAC;EAC9B,OAAQV,eAAe,CAACuC,SAAS,EAAEa,YAAY,EAAE1C,GAAG,EAAE,CAAC,CAAC,CAAC,IACrDX,YAAY,CAACmD,IAAI,EAAEG,SAAS,CAACS,YAAY,CAACC,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;AAC1E;AACAtE,OAAO,CAACK,uBAAuB,GAAGA,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,uBAAuBA,CAACmE,OAAO,EAAEzB,SAAS,EAAE0B,IAAI,EAAE;EACvD,IAAIC,OAAO,GAAGD,IAAI,IAAI,CAAC,CAAC;EACxB,IAAIE,UAAU;EACd,IAAID,OAAO,CAACxD,GAAG,EAAE;IACb;IACAyD,UAAU,GAAGD,OAAO,CAACxD,GAAG;EAC5B,CAAC,MACI;IACD;IACA,IAAIE,QAAQ,GAAGsD,OAAO,CAACtD,QAAQ,IAAIoD,OAAO,CAACpD,QAAQ;IACnD,IAAIG,IAAI,GAAGmD,OAAO,CAACnD,IAAI,IAAIiD,OAAO,CAACI,OAAO,CAACrD,IAAI;IAC/CoD,UAAU,GAAG7D,KAAK,CAACuC,OAAO,CAACwB,MAAM,CAAC;MAC9BzD,QAAQ,EAAEA,QAAQ;MAClBG,IAAI,EAAEA,IAAI;MACVC,QAAQ,EAAEgD,OAAO,CAACM;IACtB,CAAC,CAAC;IACF,IAAIN,OAAO,CAACM,WAAW,CAACrD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;MACvCkD,UAAU,GAAGA,UAAU,CAACI,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;IAChD;EACJ;EACA,IAAIJ,UAAU,CAAC1B,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;IACtC,OAAO3C,uBAAuB,CAACyC,SAAS,EAAEyB,OAAO,CAACQ,MAAM,CAAC,oBAAoB,CAAC,IAAI,EAAE,EAAEL,UAAU,EAAEH,OAAO,CAACS,OAAO,IAAI,IAAI,CAAC;EAC9H,CAAC,MACI;IACD,OAAOzE,eAAe,CAACuC,SAAS,EAAEyB,OAAO,CAACQ,MAAM,CAAC,oBAAoB,CAAC,IAAI,EAAE,EAAEL,UAAU,EAAEH,OAAO,CAACd,IAAI,IAAI,CAAC,CAAC,CAAC;EACjH;AACJ;AACAzD,OAAO,CAACI,uBAAuB,GAAGA,uBAAuB;AACzD,SAASD,sBAAsBA,CAACoE,OAAO,EAAEzB,SAAS,EAAE0B,IAAI,EAAE;EACtD,OAAOpE,uBAAuB,CAACmE,OAAO,EAAEzB,SAAS,EAAE0B,IAAI,CAAC;AAC5D;AACAxE,OAAO,CAACG,sBAAsB,GAAGA,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,OAAOA,CAACsE,IAAI,EAAE1B,SAAS,EAAE;EAC9B,IAAImC,KAAK;EACT,IAAIR,OAAO,GAAGS,SAAS;EACvB;EACA,IAAIV,IAAI,EAAE;IACN,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC1BS,KAAK,GAAGT,IAAI;IAChB;IACA,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC1BC,OAAO,GAAGD,IAAI;IAClB;EACJ;EACA,IAAI1B,SAAS,EAAE;IACX,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;MAC/BmC,KAAK,GAAGnC,SAAS;IACrB;IACA,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;MAC/B2B,OAAO,GAAG3B,SAAS;IACvB;EACJ;EACA,IAAI,CAAC2B,OAAO,EACRA,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIA,OAAO,CAACU,QAAQ,IAAID,SAAS,EAC7BT,OAAO,CAACU,QAAQ,GAAG,IAAI;EAC3B;EACA,IAAIC,WAAW;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEH,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IAC9C,IAAII,GAAG,GAAGF,SAAS,CAACF,CAAC,CAAC;IACtB,IAAI,OAAOI,GAAG,KAAK,QAAQ,EAAE;MACzBL,WAAW,GAAGK,GAAG;IACrB,CAAC,MACI;MACDhB,OAAO,GAAG3E,MAAM,CAAC4F,MAAM,CAACjB,OAAO,IAAI,CAAC,CAAC,EAAEgB,GAAG,CAAC;IAC/C;EACJ;EACA;EACA,IAAIhB,OAAO,EAAE;IACTA,OAAO,CAAC3B,SAAS,GAAGsC,WAAW,GACzBA,WAAW,GACXO,OAAO,CAACC,GAAG,CAACC,iBAAiB;EACvC;EACA;EACA,OAAO,SAASC,IAAIA,CAACvB,OAAO,EAAEwB,QAAQ,EAAEC,IAAI,EAAE;IAC1C;IACA,IAAIvB,OAAO,EAAEU,QAAQ,EAAE;MACnB;MACA,IAAI,CAACZ,OAAO,CAACQ,MAAM,CAAC,oBAAoB,CAAC,EAAE;QACvC,OAAOgB,QAAQ,CACVE,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,GAAG,CAAC,CACXC,IAAI,CAAC,qHAAqH,CAAC;MACpI;MACA;MACA,IAAI,CAAC1B,OAAO,EAAE3B,SAAS,EAAE;QACrBsD,OAAO,CAACC,KAAK,CAAC,iFAAiF,CAAC;QAChGN,QAAQ,CACHE,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,GAAG,CAAC,CACXC,IAAI,CAAC,iGAAiG,CAAC;MAChH,CAAC,MACI;QACD;QACA,IAAIG,KAAK,GAAGnG,sBAAsB,CAACoE,OAAO,EAAEE,OAAO,EAAE3B,SAAS,EAAE;UAC5D7B,GAAG,EAAEwD,OAAO,EAAExD,GAAG;UACjBK,IAAI,EAAEmD,OAAO,EAAEnD,IAAI;UACnBH,QAAQ,EAAEsD,OAAO,EAAEtD;QACvB,CAAC,CAAC;QACF,IAAImF,KAAK,EAAE;UACPN,IAAI,CAAC,CAAC;QACV,CAAC,MACI;UACD,OAAOD,QAAQ,CACVE,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,GAAG,CAAC,CACXC,IAAI,CAAC,mCAAmC,CAAC;QAClD;MACJ;IACJ,CAAC,MACI;MACDH,IAAI,CAAC,CAAC;IACV;EACJ,CAAC;AACL;AACAhG,OAAO,CAACE,OAAO,GAAGA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}